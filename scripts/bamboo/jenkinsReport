#! /usr/bin/env python

import datetime
import operator
import os
import re
import sys

from smtplib import SMTP
from email.MIMEText import MIMEText
from optparse import OptionParser
from collections import deque


__cellBlackOnGreen = "<td bgcolor=\"#00C000\"><font  color=\"#000000\">%s</font></td>"
__cellWhiteOnRed = "<td bgcolor=\"#E10000\"><font color=\"#FFFFFF\">%s</font></td>"
__contentHeader = "<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"></head><body>"
__contentFooter = "</body></html>"


def parseCommandLineOptions(commandlineArgs):
    parser = OptionParser(conflict_handler="resolve")

    parser.add_option("-e", "--email", action="store", dest="email", default="", help="Email report results to only list specified on the command line. (Comma delimited, no spaces)")
    parser.add_option("-f", "--file", action="store", dest="file", default="", help="Output file for report")
    parser.add_option("--filter", action="store", dest="filter", default="", help="Jobs to be filtered from email (comma delimited)")

    (opts, args) = parser.parse_args(commandlineArgs)

    #Handle command line option errors
    if len(commandlineArgs) < 1:
        logger.writeError("At least 1 command line argument is needed.")
        return False, None

    return True, opts


class jobInfo(object):
    def __init__(self):
        self.name = ""
        self.success = ""
        self.datetime = ""
        self.errorMessage = ""


def __getResultsColor(success, successColor, failureColor):
    if success:
        return successColor
    return failureColor


def __jobNameToHTMLLink(jobName):
    return jobName.strip().lower().replace(" ", "")


def __generateBuildEmailHtml(jobInfos):
    errorsHtml = ""

    html = __contentHeader
    html += "<center><font size=\"4\">Job Status</font></center>"
    html += "<center><table border=\"1\">"
    html += "<tr>"
    html += "<th bgcolor=\"#C0C0C0\">Job Name</th>"
    html += "<th bgcolor=\"#C0C0C0\">Date</th>"
    html += "<th bgcolor=\"#C0C0C0\">Success</th>"
    html += "<th bgcolor=\"#C0C0C0\">Errors</th>"
    html += "</tr>\n"

    for currJobInfo in jobInfos:
        html += "<tr>"
        html += "<td>{0}</td>".format(currJobInfo.name)

        dateString = ""
        if currJobInfo.datetime != "":
            dt = datetime.datetime.strptime(currJobInfo.datetime, "%Y-%m-%d_%H-%M-%S")
            dateString = dt.strftime("%a, %d %b %Y %H:%M:%S")
        html += "<td>{0}</td>".format(dateString)

        html += __getResultsColor(currJobInfo.success, __cellBlackOnGreen, __cellWhiteOnRed) % str(currJobInfo.success)
        if not currJobInfo.success:
            html += "<td><a href=\"#{0}\">Link</a></td>".format(__jobNameToHTMLLink(currJobInfo.name))
        else:
            html += "<td/>"

        html += "</tr>\n"
        if currJobInfo.errorMessage != "":
            link = "<a name=\"{0}\" id=\"{0}\">{1}</a>".format(__jobNameToHTMLLink(currJobInfo.name), currJobInfo.name)
            errorsHtml += "<center><p><font size=\"4\">{0}</font></p></center><br/><p>{1}</p>".format(link, currJobInfo.errorMessage)
            errorsHtml += "<br/><hr noshade size=3 width=\"75%\" line=\"center\">\n"

    html += "</table></center>\n"
    if errorsHtml != "":
        html += "<br/><hr noshade size=7>"
        html += errorsHtml
        if html.endswith("<hr noshade size=3 width=\"75%\" line=\"center\">"):
            html = html[:-len("<hr noshade size=3 width=\"75%\" line=\"center\">")]

    html += __contentFooter
    return html


def __normalizePath(path):
    return os.path.normpath(os.path.realpath(os.path.abspath(path)))


def __tail(filename, n=10):
    return "".join(list(deque(open(filename), n)))


def __getBuildLogTail(buildPath):
    message = __tail(os.path.join(buildPath, "log"), 100)
    message = message.replace("\n", "<br/>")
    return message


def __getBuildDateTime(path):
    fileContents = ""
    buildInfoPath = os.path.join(path, "build.xml")
    timestamp = 0
    if os.path.exists(buildInfoPath):
       with open(buildInfoPath, "r") as f:
          fileContents = f.read()
       searchObj = re.search('\<startTime\>(.*)\<\/startTime\>', fileContents)
       if searchObj:
          # timestamp is in milliseconds, need to convert to seconds
          timestamp = int(searchObj.group(1))/1000.
    return datetime.datetime.utcfromtimestamp(timestamp).strftime("%Y-%m-%d_%H-%M-%S")


def generateJobReportContents(opts):
    jobsPath = os.path.join(os.path.join(os.environ['HOME'], ".jenkins"),"jobs")

    filteredJobs = opts.filter.strip().split(",")
    filteredJobs = [x.strip().lower() for x in filteredJobs]

    jobInfos = []
    try:
       jobNames = [name for name in os.listdir(jobsPath) if os.path.isdir(os.path.join(jobsPath, name))]
       for jobName in jobNames:
           if jobName.strip().lower() in filteredJobs:
               print "Job Filtered: {0}".format(jobName)
               continue

           currJobInfo = jobInfo()
           currJobInfo.name = jobName
           jobBuildsPath = os.path.join(os.path.join(jobsPath, jobName), "builds")

           lastSuccessfulPath = os.path.join(jobBuildsPath, "lastSuccessfulBuild")
           lastSuccessfulPath = __normalizePath(lastSuccessfulPath)
           lastFailedPath = os.path.join(jobBuildsPath, "lastFailedBuild")
           lastFailedPath = __normalizePath(lastFailedPath)

           lastSuccessfulDateTime = __getBuildDateTime(lastSuccessfulPath)
           lastFailedDateTime = __getBuildDateTime(lastFailedPath)

           if not os.path.exists(lastSuccessfulPath) and not os.path.exists(lastFailedPath):
               currJobInfo.success = False
               currJobInfo.errorMessage = "This job has no history."
           elif not os.path.exists(lastSuccessfulPath) and os.path.exists(lastFailedPath):
               currJobInfo.success = False
               currJobInfo.datetime = lastFailedDateTime
               currJobInfo.errorMessage = __getBuildLogTail(lastFailedPath)
           elif os.path.exists(lastSuccessfulPath) and not os.path.exists(lastFailedPath):
               currJobInfo.success = True
               currJobInfo.datetime = lastSuccessfulDateTime
           elif lastSuccessfulDateTime < lastFailedDateTime:
               currJobInfo.success = False
               currJobInfo.errorMessage = __getBuildLogTail(lastFailedPath)
               currJobInfo.datetime = lastFailedDateTime
           else:
               currJobInfo.success = True
               currJobInfo.datetime = lastSuccessfulDateTime

           jobInfos.append(currJobInfo)
    except OSError:
       print "Could not read {0}".format(jobsPath)

    jobInfos.sort(key=operator.attrgetter('name'))
    content = __generateBuildEmailHtml(jobInfos)
    return content


def sendEmail(content, subject, sender, reciever, emailServer):
    try:
        msg = MIMEText(content, "html")
        msg["Subject"] = subject
        msg["From"] = sender
        msg["To"] = reciever
        msg["Content-Type"] = "text/html"

        conn = SMTP(emailServer)
        conn.set_debuglevel(False)
        try:
            conn.sendmail(sender, reciever, msg.as_string())
        finally:
            conn.close()
    except Exception as e:
        print "Failed to send email:\n {0}".format(str(e))
        return False
    print "Sent."

    return True


def main():
    #Parse command line options
    parseSuccess, opts = parseCommandLineOptions(sys.argv[1:])
    if not parseSuccess:
        return False

    #Generate job report contents contents
    print "Generating Contents"
    jobReportContents = generateJobReportContents(opts)

    #Send email
    if not opts.email == "":
        print "Emailing contents..."
        buildEmailSubject = "[ Axom ] Build Status"
        sender = "axom-no-reply@llnl.gov"
        emailServer = "nospam.llnl.gov"
        reciever = opts.email
        if not isinstance(reciever, basestring):
            reciever = "; ".join(reciever)
        sendEmail(jobReportContents, buildEmailSubject, sender, opts.email, emailServer)

    #Output contents to file
    if not opts.file == "":
        print "Saving Contents..\n  Path: " + opts.file
        if (os.path.exists(opts.file)):
            os.remove(opts.file)
        with open(opts.file, "w") as f:
            f.write(jobReportContents)
        print "Done."
   
    return True

if __name__ == "__main__":
    if not main():
        sys.exit(1)
    sys.exit(0)
