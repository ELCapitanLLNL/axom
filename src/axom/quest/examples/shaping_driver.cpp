// Copyright (c) 2017-2021, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

/*!
 * \file shaping_driver.cpp
 * \brief Driver for shaping material volume fractions onto a simulation mesh
 */

// Axom includes
#include "axom/core.hpp"
#include "axom/slic.hpp"
#include "axom/slam.hpp"
#include "axom/sidre.hpp"
#include "axom/primal.hpp"
#include "axom/spin.hpp"
#include "axom/klee.hpp"
#include "axom/mint.hpp"
#include "axom/quest.hpp"

#include "fmt/fmt.hpp"
#include "fmt/locale.h"
#include "CLI11/CLI11.hpp"

#include "mfem.hpp"

// C/C++ includes
#include <algorithm>
#include <cmath>
#include <iostream>
#include <limits>
#include <fstream>
#include <iomanip>  // for setprecision()

#include "mpi.h"

// NOTE: Axom must be configured with AXOM_ENABLE_MFEM_SIDRE_DATACOLLECTION compiler define for the klee containment driver

namespace mint = axom::mint;
namespace quest = axom::quest;
namespace slic = axom::slic;
namespace sidre = axom::sidre;
namespace klee = axom::klee;

using QFunctionCollection = mfem::NamedFieldsMap<mfem::QuadratureFunction>;
using DenseTensorCollection = mfem::NamedFieldsMap<mfem::DenseTensor>;

using VolFracSampling = quest::shaping::VolFracSampling;

//------------------------------------------------------------------------------

/** Struct to parse and store the input parameters */
struct Input
{
public:
  std::string meshFile;

  std::string shapeFile;
  klee::ShapeSet shapeSet;

  int quadratureOrder {5};
  int outputOrder {2};
  int samplesPerKnotSpan {25};
  double weldThresh = 1E-9;

  VolFracSampling vfSampling {VolFracSampling::SAMPLE_AT_QPTS};

  std::vector<double> queryBoxMins;
  std::vector<double> queryBoxMaxs;

private:
  bool m_verboseOutput {false};

public:
  Input() = default;

  bool isVerbose() const { return m_verboseOutput; }

  std::string getDCMeshName() const
  {
    using axom::utilities::string::endsWith;

    std::string name = axom::Path(meshFile).baseName();
    std::string suffix = ".root";
    if(endsWith(name, suffix))
    {
      name = name.substr(0, name.size() - suffix.size());
    }

    return name;
  }

  void parse(int argc, char** argv, CLI::App& app)
  {
    app.add_option("-m,--mesh-file", meshFile)
      ->description(
        "Path to computational mesh (generated by MFEMSidreDataCollection)")
      ->check(CLI::ExistingFile)
      ->required();

    app.add_option("-i,--shape-file", shapeFile)
      ->description("Path to input shape file")
      ->check(CLI::ExistingFile)
      ->required();

    app.add_flag("-v,--verbose", m_verboseOutput)
      ->description("Enable/disable verbose output")
      ->capture_default_str();

    app.add_option("-o,--order", outputOrder)
      ->description("order of the output grid function")
      ->capture_default_str()
      ->check(CLI::NonNegativeNumber);

    app.add_option("-q,--quadrature-order", quadratureOrder)
      ->description(
        "Quadrature order for sampling the inout field. \n"
        "Determines number of samples per element in determining "
        "volume fraction field")
      ->capture_default_str()
      ->check(CLI::PositiveNumber);

    std::map<std::string, VolFracSampling> vfsamplingMap {
      {"qpts", VolFracSampling::SAMPLE_AT_QPTS},
      {"dofs", VolFracSampling::SAMPLE_AT_DOFS}};
    app.add_option("-s,--sampling-type", vfSampling)
      ->description(
        "Sampling strategy. \n"
        "Sampling either at quadrature points or collocated with "
        "degrees of freedom")
      ->capture_default_str()
      ->transform(CLI::CheckedTransformer(vfsamplingMap, CLI::ignore_case));

    app.add_option("-n,--segments-per-knot-span", samplesPerKnotSpan)
      ->description(
        "(2D only) Number of linear segments to generate per NURBS knot span")
      ->capture_default_str()
      ->check(CLI::PositiveNumber);

    app.add_option("-t,--weld-threshold", weldThresh)
      ->description("Threshold for welding")
      ->check(CLI::NonNegativeNumber)
      ->capture_default_str();

    app.get_formatter()->column_width(35);

    // could throw an exception
    app.parse(argc, argv);

    slic::setLoggingMsgLevel(m_verboseOutput ? slic::message::Debug
                                             : slic::message::Info);
  }
};

/// Print some info about the mesh
void printMeshInfo(mfem::Mesh* mesh)
{
  namespace primal = axom::primal;

  mfem::Vector mins, maxs;
  mesh->GetBoundingBox(mins, maxs);
  switch(mesh->Dimension())
  {
  case 2:
    SLIC_INFO(fmt::format(
      "mesh has {} elements and (approximate) bounding box {}",
      mesh->GetNE(),
      primal::BoundingBox<double, 2>(primal::Point<double, 2>(mins.GetData()),
                                     primal::Point<double, 2>(maxs.GetData()))));
    break;
  case 3:
    SLIC_INFO(fmt::format(
      "mesh has {} elements and (approximate) bounding box {}",
      mesh->GetNE(),
      primal::BoundingBox<double, 3>(primal::Point<double, 3>(mins.GetData()),
                                     primal::Point<double, 3>(maxs.GetData()))));
    break;
  }
  slic::flushStreams();
}

//------------------------------------------------------------------------------
int main(int argc, char** argv)
{
  MPI_Init(&argc, &argv);

  axom::slic::SimpleLogger logger;  // create & initialize logger
  // slic::debug::checksAreErrors = true;

  // Set up and parse command line arguments
  Input params;
  CLI::App app {"Driver for In/Out surface containment query"};

  try
  {
    params.parse(argc, argv, app);
  }
  catch(const CLI::ParseError& e)
  {
    return app.exit(e);
  }

  // Load shape file and extract info
  params.shapeSet = klee::readShapeSet(params.shapeFile);
  const klee::Dimensions shapeDim = params.shapeSet.getDimensions();

  // Error checking
#ifndef AXOM_USE_C2C
  SLIC_ERROR_IF(shapeDim == klee::Dimension::Two,
                "Shaping with contour files requires an Axom configured with "
                "the C2C library");
#endif

  const bool dc_owns_data = true;
  sidre::MFEMSidreDataCollection originalMeshDC(params.getDCMeshName(),
                                                nullptr,
                                                dc_owns_data);
  originalMeshDC.SetComm(MPI_COMM_WORLD);
  {
    std::string protocol = "sidre_hdf5";
    originalMeshDC.Load(params.meshFile, protocol);
  }

  // Set up data collection for shaping
  sidre::MFEMSidreDataCollection shapingDC("shaping", nullptr, dc_owns_data);
  {
    shapingDC.SetMeshNodesName("positions");

    auto* pmesh = dynamic_cast<mfem::ParMesh*>(originalMeshDC.GetMesh());
    mfem::Mesh* shapingMesh = (pmesh != nullptr)
      ? new mfem::ParMesh(*pmesh)
      : new mfem::Mesh(*originalMeshDC.GetMesh());
    shapingDC.SetMesh(shapingMesh);
  }
  printMeshInfo(shapingDC.GetMesh());

  // Add the mesh to an mfem data collection
  quest::MFEMShaping shaper(params.shapeSet, &shapingDC);

  const int sampleOrder = params.quadratureOrder;
  const int outputOrder = params.outputOrder;

  shaper.setSamplesPerKnotSpan(params.samplesPerKnotSpan);
  shaper.setVertexWeldThreshold(params.weldThresh);

  // Sample the InOut quadrature field for each shape using an InOut octree
  // Assumptions: Each shape has a unique name
  SLIC_INFO(fmt::format("{:=^80}", "Sampling InOut fields for shapes"));
  for(const auto& s : params.shapeSet.getShapes())
  {
    shaper.loadShape(s);

    // Compute mesh bounding box and log some stats about the surface
    shaper.prepareShapeQuery(shapeDim, s);

    shaper.runShapeQuery(params.vfSampling, sampleOrder, outputOrder);

    shaper.finalizeShapeQuery();
  }

  auto& inoutQFuncs = shaper.getInoutQFuncs();

  // Apply replacement rules to the quadrature points
  // Assumptions: The replacement rules have been validated, yielding a valid DAG for the replacements
  SLIC_INFO(
    fmt::format("{:=^80}", "Applying replacement rules over the shapes"));

  // generate a map from materials to shape names
  std::map<std::string, std::vector<std::string>> materialsToShapes;
  {
    for(const auto& s : params.shapeSet.getShapes())
    {
      materialsToShapes[s.getMaterial()].push_back(s.getName());
    }

    // generate a map from materials to set of materials that it is replaced by
    std::map<std::string, std::set<std::string>> replaced_by;
    for(const auto& s : params.shapeSet.getShapes())
    {
      auto& material_s = s.getMaterial();
      for(const auto& t : params.shapeSet.getShapes())
      {
        auto& material_t = t.getMaterial();
        if(material_s != material_t && s.replaces(material_t))
        {
          replaced_by[material_t].insert(material_s);
        }
      }
    }

    SLIC_INFO("Replacement rules:");
    for(const auto& s : params.shapeSet.getShapes())
    {
      SLIC_INFO(fmt::format("Shape '{}' of material {} is replaced by: [{}]",
                            s.getName(),
                            s.getMaterial(),
                            fmt::join(replaced_by[s.getMaterial()], " ")));
    }

    // Merge all shapes of a given material into a single material QFunc
    for(const auto& kv : materialsToShapes)
    {
      auto& mat = kv.first;
      quest::shaping::mergeQFuncs(mat, kv.second, inoutQFuncs);
    }

    // Merge all shapes of a given material into a single material QFunc
    for(const auto& kv : replaced_by)
    {
      auto& mat = kv.first;
      quest::shaping::replaceMaterials(mat, kv.second, inoutQFuncs);
    }
  }
  // Generate the volume fractions from the InOut quadrature fields
  SLIC_INFO(
    fmt::format("{:=^80}", "Generating volume fraction fields for materials"));
  for(const auto& kv : materialsToShapes)
  {
    const std::string shapeName = kv.first;
    const int outputOrder = params.outputOrder;

    SLIC_INFO(fmt::format("Generating volume fraction fields for '{}' shape",
                          shapeName));

    switch(params.vfSampling)
    {
    case VolFracSampling::SAMPLE_AT_QPTS:
      quest::shaping::computeVolumeFractions(shapeName,
                                             shaper.getDC(),
                                             inoutQFuncs,
                                             outputOrder);
      break;
    case VolFracSampling::SAMPLE_AT_DOFS:
      /* no-op for now */
      break;
    }
  }

// Save meshes and fields
#ifdef MFEM_USE_MPI
  shaper.getDC()->Save();
#endif

  MPI_Finalize();

  return 0;
}
