// Copyright (c) 2017-2022, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

/*!
 * \file evaluate_integral.hpp
 *
 * \brief Consists of methods that evaluate integrals over regions defined
 * by Bezier curves, such as 2D area integrals and scalar/vector field line integrals
 *
 * Line integrals are computed with simple 1D Gaussian Quadrature using rules generated
 * by MFEM. 2D area integrals computed with "Spectral Mesh-Free Quadrature for Planar 
 * Regions Bounded by Rational Parametric Curves" by David Gunerman et al.
 */

#ifndef QUEST_EVAL_INTEGRAL_INTERFACE_HPP_
#define QUEST_EVAL_INTEGRAL_INTERFACE_HPP_

// Axom includes
#include "axom/config.hpp"  // for compile-time configuration options
#include "axom/primal.hpp"

// MFEM includes
#ifdef AXOM_USE_MFEM
  #include "mfem.hpp"
#else
  #error "Primal's integral evaluation functions require mfem library."
#endif

// C++ includes
#include <cmath>

// Create type definitions the different field types (vector vs scalar)
//   to allow for proper overloading of line integrals
using Point2D = axom::primal::Point<double, 2>;
using Vector2D = axom::primal::Vector<double, 2>;

typedef std::function<Vector2D(Point2D)> vector_field;
typedef std::function<double(Point2D)> scalar_field;

namespace axom
{
namespace primal
{

/*!
 * \brief Computes the tangent vector to a Bezier curve.
 * 
 * Uses the de Casteljau algorithm. Functionality will eventually
 * be supplanted by Bezier curve class method.
 * 
 * \param [in] c the Bezier curve
 * \param [in] t on [0, 1] the parameter value on which to evaluate the derivative
 * \return the tangent vector
 */
template <typename T>
primal::Vector<double, 2> temp_dt(const primal::BezierCurve<double, 2>& c, T t)
{
  Vector<double, 2> val;

  const int ord = c.getOrder();
  std::vector<T> dCarray(ord + 1);

  // Run de Casteljau algorithm on each dimension
  for(int i = 0; i < 2; ++i)
  {
    for(int p = 0; p <= ord; ++p)
    {
      dCarray[p] = c[p][i];
    }

    // stop one step early and take difference of last two values
    for(int p = 1; p <= ord - 1; ++p)
    {
      const int end = ord - p;
      for(int k = 0; k <= end; ++k)
      {
        dCarray[k] = (1 - t) * dCarray[k] + t * dCarray[k + 1];
      }
    }
    val[i] = ord * (dCarray[1] - dCarray[0]);
  }

  return val;
}

/*!
 * \brief Evaluate a line integral along a collection of Bezier curves
 *
 * The curve need not be connected, simply adding the portion along each segment.
 * Uses Gaussian quadrature generated by MFEM.
 *
 * \param [in] cs the array of Bezier curve objects
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input, and return a double (scalar field) or 
 * 2D vector object (vector field).
 * \param [in] npts the number of Gaussian quadrature nodes for each component
 * \return the value of the integral
 */
template <class Lambda>
double evaluate_line_integral(const axom::Array<primal::BezierCurve<double, 2>>& cs,
                              Lambda&& integrand,
                              int npts)
{
  // Generate quadrature library, defaulting to GaussLegendre quadrature.
  //  Use the same one for every curve in the polygon
  //  Quadrature order is equal to 2*N - 1
  mfem::IntegrationRules my_IntRules(mfem::Quadrature1D::GaussLegendre);
  const mfem::IntegrationRule* quad =
    &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts - 1));

  double total_integral = 0.0;
  for(int i = 0; i < cs.size(); i++)
  {
    // Compute the line integral along each component
    total_integral += evaluate_line_integral(cs[i], integrand, quad);
  }

  return total_integral;
}

/*!
 * \brief Evaluate a line integral on a single Bezier curve.
 *
 * Evaluate the line integral with a given number of Gaussian
 * quadrature nodes generated by MFEM.
 *
 * \param [in] c the Bezier curve object
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input, and return a double (scalar field) or 
 * 2D vector object (vector field).
 * \param [in] npts the number of quadrature nodes
 * \return the value of the integral
 */
template <class Lambda>
double evaluate_line_integral(const primal::BezierCurve<double, 2>& c,
                              Lambda&& integrand,
                              int npts)
{
  // Generate quadrature library, defaulting to GaussLegendre quadrature.
  //  Use the same one for every curve in the polygon
  //  Quadrature order is equal to 2*N - 1
  mfem::IntegrationRules my_IntRules(mfem::Quadrature1D::GaussLegendre);
  const mfem::IntegrationRule* quad =
    &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts - 1));

  return evaluate_line_integral(c, integrand, quad);
}

/*!
 * \brief Evaluate a scalar field line integral on a single Bezier curve.
 *
 * Evaluate the scalar field line integral with MFEM integration rule
 *
 * \param [in] c the Bezier curve object
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input and return a double
 * \param [in] quad the mfem integration rule containing nodes and weights
 * \return the value of the integral
 */
inline double evaluate_line_integral(const primal::BezierCurve<double, 2>& c,
                                     scalar_field integrand,
                                     const mfem::IntegrationRule* quad)
{
  // Store intermediate values
  Point2D x_q;
  Vector2D dx_q;

  // Store/compute quadrature result
  double full_quadrature = 0.0;
  for(int q = 0; q < quad->GetNPoints(); q++)
  {
    // Get intermediate quadrature point
    //  at which to evaluate tangent vector
    x_q = c.evaluate(quad->IntPoint(q).x);
    dx_q = temp_dt(c, quad->IntPoint(q).x);

    full_quadrature += quad->IntPoint(q).weight * integrand(x_q) * dx_q.norm();
  }

  return full_quadrature;
}

/*!
 * \brief Evaluate a vector field line integral on a single Bezier curve.
 *
 * Evaluate the vector field line integral with MFEM integration rule
 *
 * \param [in] c the Bezier curve object
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input and return a 2D axom vector object
 * \param [in] quad the mfem integration rule containing nodes and weights
 * \return the value of the integral
 */
inline double evaluate_line_integral(const primal::BezierCurve<double, 2>& c,
                                     vector_field vec_field,
                                     const mfem::IntegrationRule* quad)
{
  // Store intermediate values.
  Point2D x_q;
  Vector2D dx_q, func_val;

  // Store/compute quadrature result
  double full_quadrature = 0.0;
  for(int q = 0; q < quad->GetNPoints(); q++)
  {
    // Get intermediate quadrature point
    //  on which to evaluate dot product
    x_q = c.evaluate(quad->IntPoint(q).x);
    dx_q = temp_dt(c, quad->IntPoint(q).x);
    func_val = vec_field(x_q);

    full_quadrature +=
      quad->IntPoint(q).weight * Vector2D::dot_product(func_val, dx_q);
  }

  return full_quadrature;
}

/*!
 * \brief Evaluate an integral across a 2D domain bounded by Bezier curves.
 *
 * Assumes that the array of Bezier curves is closed and connected. Will compute
 * the integral regardless, but the result will be meaningless.
 * Will eventually incorperate the CurverdPolygon class.
 * Uses a Spectral Mesh-Free Quadrature derived from Green's theorem, evaluating
 * the area integral as a line integral of the antiderivative over the curve.
 *
 * \param [in] cs the array of Bezier curve objects that bound the region
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input and return a double
 * \param [in] npts_Q the number of quadrature points to evaluate the line integral
 * \param [in] npts_P the number of quadrature points to evaluate the antiderivative
 * \return the value of the integral
 */
template <class Lambda>
double evaluate_area_integral(const axom::Array<primal::BezierCurve<double, 2>>& cs,
                              Lambda&& integrand,
                              int npts_Q,
                              int npts_P = 0)
{
  // Generate quadrature library, defaulting to GaussLegendre quadrature.
  //  Use the same one for every curve in the polygon
  mfem::IntegrationRules my_IntRules(mfem::Quadrature1D::GaussLegendre);
  const mfem::IntegrationRule *quad_Q, *quad_P;

  // Get the quadrature for the line integral.
  //  Quadrature order is equal to 2*N - 1
  quad_Q = &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts_Q - 1));

  // If the quadrature orders are the same (which they usually are),
  //  then only create one quadrature within the library and then
  //  the two pointers can point to the same object. Hopefully improves efficiency.
  if(npts_P <= 0)
  {
    npts_P = npts_Q;
    quad_P = quad_Q;
  }
  else
  {
    quad_P = &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts_P - 1));
  }

  // Define lower bound as lowest control node for all curves
  double int_lb = cs[0][0][1];  // Start as y-component of first node
  for(int i = 0; i < cs.size(); i++)
    for(int j = 1; j < cs[i].getOrder() + 1; j++)
      int_lb = std::min(int_lb, cs[i][j][1]);

  // Evaluate the antiderivative line integral along each component
  double total_integral = 0.0;
  for(int i = 0; i < cs.size(); i++)
  {
    total_integral +=
      evaluate_area_integral(cs[i], integrand, int_lb, quad_Q, quad_P);
  }

  return total_integral;
}

/*!
 * \brief Evaluate the integral across a single component of the curved polygon.
 *
 * Uses a Spectral Mesh-Free Quadrature derived from Green's theorem, evaluating
 * the area integral as a line integral of the antiderivative over the curve.
 *
 * \param [in] cs the array of Bezier curve objects that bound the region
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input and return a double
 * \param [in] The lower bound of integration for the antiderivatives
 * \param [in] quad_Q the quadrature rule for the line integral
 * \param [in] quad_P the quadrature rule for the antiderivative
 * \return the value of the integral, which is mathematically meaningless.
 */
template <class Lambda>
double evaluate_area_integral(const primal::BezierCurve<double, 2>& c,
                              Lambda&& integrand,
                              double int_lb,
                              const mfem::IntegrationRule* quad_Q,
                              const mfem::IntegrationRule* quad_P)
{
  // Store some intermediate values
  Point2D x_q, x_qxi;
  double antiderivative = 0.0;

  // Store/compute quadrature result
  double full_quadrature = 0.0;
  for(int q = 0; q < quad_Q->GetNPoints(); q++)
  {
    // Get intermediate quadrature point
    //  on which to evaluate antiderivative
    x_q = c.evaluate(quad_Q->IntPoint(q).x);

    // Evaluate the antiderivative at x_q, add it to full quadrature
    for(int xi = 0; xi < quad_P->GetNPoints(); xi++)
    {
      // Define interior quadrature points
      x_qxi[0] = x_q[0];
      x_qxi[1] = (x_q[1] - int_lb) * quad_P->IntPoint(xi).x + int_lb;

      antiderivative =
        quad_P->IntPoint(xi).weight * (x_q[1] - int_lb) * integrand(x_qxi);

      // TODO: Check if the antiderivative should be negated for Green's theorem
      full_quadrature += quad_Q->IntPoint(q).weight *
        temp_dt(c, quad_Q->IntPoint(q).x)[0] * -antiderivative;
      //full_quadrature += quad_Q->IntPoint(q).weight *
      //  temp_dt(c, quad_Q->IntPoint(q).x)[0] * antiderivative;
    }
  }

  return full_quadrature;
}

}  // namespace primal
}  // end namespace axom

#endif
