// Copyright (c) 2017-2022, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

/*!
 * \file evaluate_integral.hpp
 *
 * \brief Consists of methods that evaluate integrals over regions defined
 * by Bezier curves, such as 2D area integrals and scalar/vector field line integrals
 *
 * Line integrals are computed with simple 1D Gaussian Quadrature using rules generated
 * by MFEM. 2D area integrals computed with "Spectral Mesh-Free Quadrature for Planar 
 * Regions Bounded by Rational Parametric Curves" by David Gunderman et al.
 */

#ifndef PRIMAL_EVAL_INTEGRAL_HPP_
#define PRIMAL_EVAL_INTEGRAL_HPP_

// Axom includes
#include "axom/config.hpp"  // for compile-time configuration options
#include "axom/primal.hpp"

#include "axom/primal/operators/detail/evaluate_integral_impl.hpp"

// MFEM includes
#ifdef AXOM_USE_MFEM
  #include "mfem.hpp"
#else
  #error "Primal's integral evaluation functions require mfem library."
#endif

// C++ includes
#include <cmath>

// Create type definitions the different field types (vector vs scalar)
//   to allow for proper overloading of line integrals
using Point2D = axom::primal::Point<double, 2>;
using Vector2D = axom::primal::Vector<double, 2>;

namespace axom
{
namespace primal
{
/*!
 * \brief Evaluate a line integral along a collection of Bezier curves
 *
 * The curve need not be connected, simply adding the portion along each segment.
 * Uses Gaussian quadrature generated by MFEM.
 *
 * \param [in] cs the array of Bezier curve objects
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input, and return a double (scalar field) or 
 * 2D vector object (vector field).
 * \param [in] npts the number of Gaussian quadrature nodes for each component
 * \return the value of the integral
 */
template <class Lambda>
double evaluate_line_integral(const axom::Array<primal::BezierCurve<double, 2>>& cs,
                              Lambda&& integrand,
                              int npts)
{
  // Generate quadrature library, defaulting to GaussLegendre quadrature.
  //  Use the same one for every curve in the polygon
  //  Quadrature order is equal to 2*N - 1
  static mfem::IntegrationRules my_IntRules(mfem::Quadrature1D::GaussLegendre);
  const mfem::IntegrationRule* quad =
    &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts - 1));

  double total_integral = 0.0;
  for(int i = 0; i < cs.size(); i++)
  {
    // Compute the line integral along each component
    total_integral +=
      detail::evaluate_line_integral_component(cs[i], integrand, quad);
  }

  return total_integral;
}

/*!
 * \brief Evaluate a line integral on a single Bezier curve.
 *
 * Evaluate the line integral with a given number of Gaussian
 * quadrature nodes generated by MFEM.
 *
 * \param [in] c the Bezier curve object
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input, and return a double (scalar field) or 
 * 2D vector object (vector field).
 * \param [in] npts the number of quadrature nodes
 * \return the value of the integral
 */
template <class Lambda>
double evaluate_line_integral(const primal::BezierCurve<double, 2>& c,
                              Lambda&& integrand,
                              int npts)
{
  // Generate quadrature library, defaulting to GaussLegendre quadrature.
  //  Use the same one for every curve in the polygon
  //  Quadrature order is equal to 2*N - 1
  static mfem::IntegrationRules my_IntRules(mfem::Quadrature1D::GaussLegendre);
  const mfem::IntegrationRule* quad =
    &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts - 1));

  return detail::evaluate_line_integral_component(c, integrand, quad);
}

/*!
 * \brief Evaluate an integral across a 2D domain bounded by Bezier curves.
 *
 * Assumes that the array of Bezier curves is closed and connected. Will compute
 * the integral regardless, but the result will be meaningless.
 * Will eventually incorperate the CurverdPolygon class.
 * Uses a Spectral Mesh-Free Quadrature derived from Green's theorem, evaluating
 * the area integral as a line integral of the antiderivative over the curve.
 *
 * \param [in] cs the array of Bezier curve objects that bound the region
 * \param [in] integrand the lambda function representing the integrand. 
 * Must accept a 2D point as input and return a double
 * \param [in] npts_Q the number of quadrature points to evaluate the line integral
 * \param [in] npts_P the number of quadrature points to evaluate the antiderivative
 * \return the value of the integral
 */
template <class Lambda>
double evaluate_area_integral(const axom::Array<primal::BezierCurve<double, 2>>& cs,
                              Lambda&& integrand,
                              int npts_Q,
                              int npts_P = 0)
{
  // Generate quadrature library, defaulting to GaussLegendre quadrature.
  //  Use the same one for every curve in the polygon
  static mfem::IntegrationRules my_IntRules(mfem::Quadrature1D::GaussLegendre);
  const mfem::IntegrationRule *quad_Q, *quad_P;

  // Get the quadrature for the line integral.
  //  Quadrature order is equal to 2*N - 1
  quad_Q = &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts_Q - 1));

  // If the quadrature orders are the same (which they usually are),
  //  then only create one quadrature within the library and then
  //  the two pointers can point to the same object. Hopefully improves efficiency.
  if(npts_P <= 0)
  {
    npts_P = npts_Q;
    quad_P = quad_Q;
  }
  else
  {
    quad_P = &(my_IntRules.Get(mfem::Geometry::SEGMENT, 2 * npts_P - 1));
  }

  // Define lower bound as lowest control node for all curves
  double int_lb = cs[0][0][1];  // Start as y-component of first node
  for(int i = 0; i < cs.size(); i++)
    for(int j = 1; j < cs[i].getOrder() + 1; j++)
      int_lb = std::min(int_lb, cs[i][j][1]);

  // Evaluate the antiderivative line integral along each component
  double total_integral = 0.0;
  for(int i = 0; i < cs.size(); i++)
  {
    total_integral += detail::evaluate_area_integral_component(cs[i],
                                                               integrand,
                                                               int_lb,
                                                               quad_Q,
                                                               quad_P);
  }

  return total_integral;
}

}  // namespace primal
}  // end namespace axom

#endif
