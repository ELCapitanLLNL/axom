!-------------------------------------------------------------------------------
!  Copyright (c) 2015, Lawrence Livermore National Security, LLC.
!  Produced at the Lawrence Livermore National Laboratory.
!
!  All rights reserved.
!
! This source code cannot be distributed without permission and
! further review from Lawrence Livermore National Laboratory.
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
! Simple Fortran example of quest usage.
!
! NOTE: assumes a "sphere.stl" file exists in the working directory.
!-------------------------------------------------------------------------------

module quest_fortran_usage

#ifndef USE_MPIF_HEADER
  use mpi
#endif
  use quest_mod
  implicit none

#ifdef USE_MPIF_HEADER
  include 'mpif.h'
#endif

  integer :: num_pts = 10, rank, nprocs, ierr
  character(LEN=40) :: FileName = "sphere.stl"
  integer :: dim = 3

contains

  !-------------------------------------------------------------------------------
  ! random_double( lb, ub )
  !
  ! Returns a random double, d, between lowerbound lb and upperbound ub
  !-------------------------------------------------------------------------------
  function random_double(lb,ub ) result(d)
    implicit none

    real*8, value, intent(in) ::  lb, ub
    real*8 :: d

    call random_number(d)
    d =  (ub-lb) * d + lb

  end function random_double

  subroutine init_mpi()
    !...initialize MPI
    call mpi_init( ierr )
    call mpi_comm_rank( MPI_COMM_WORLD, rank, ierr )
    call mpi_comm_size( MPI_COMM_WORLD, nprocs, ierr )
  end subroutine init_mpi

  subroutine finalize_mpi()
    !... finalize MPI
    call mpi_finalize( ierr )
  end subroutine finalize_mpi

  !-------------------------------------------------------------------------------
  ! run_distance_queries( rank )
  !
  ! Exercises the distance query functionality of quest on a given mpi rank
  !-------------------------------------------------------------------------------
  subroutine run_distance_queries()
    implicit none

    integer :: i, ins
    real*8  :: x, y, z, phi
    integer :: bucket_size = 25
    integer :: depth = 10
    real*8 :: mesh_bb_min(3), mesh_bb_max(3), mesh_center_of_mass(3)
    character(LEN=40) :: Format = "(I2, F6.2, F6.2, F6.2, F6.2, I3)"

    if (rank == 0) then
      write(*,*) "** Running distance queries using quest fortran interface"
      write(*,*) "[rank, (x,y,z), dist, within]"
    end if


    !...initialize quest
    call quest_initialize( MPI_COMM_WORLD, FileName, .true., dim, bucket_size, depth )
    call quest_mesh_bounds_min(mesh_bb_min)
    call quest_mesh_bounds_max(mesh_bb_max)
    call quest_mesh_center_of_mass(mesh_center_of_mass)

    !... Create random pts and query surface distance and containment
    do i=1,num_pts + 1
      if (i == 1) then
        x = mesh_center_of_mass(1)
        y = mesh_center_of_mass(2)
        z = mesh_center_of_mass(3)
      else
        x = random_double( mesh_bb_min(1), mesh_bb_max(1) )
        y = random_double( mesh_bb_min(2), mesh_bb_max(2) )
        z = random_double( mesh_bb_min(3), mesh_bb_max(3) )
      end if

      phi = quest_distance( x, y, z )
      ins = quest_inside(x,y,z)

      write(*,Format) rank, x, y, z, phi, ins
    end do

    !...finalize quest
    call quest_finalize()

  end subroutine run_distance_queries


  !-------------------------------------------------------------------------------
  ! run_containment_queries( rank )
  !
  ! Exercises the containment query functionality of quest on a given mpi rank
  !-------------------------------------------------------------------------------
  subroutine run_containment_queries()
    implicit none

    integer :: i, ins
    real*8  :: x, y, z
    integer :: unused = -1
    real*8 :: mesh_bb_min(3), mesh_bb_max(3), mesh_center_of_mass(3)
    character(LEN=40) :: Format = "(I2, F6.2, F6.2, F6.2, I3)"

    if (rank == 0) then
      write(*,*) "** Running containment queries using quest fortran interface"
      write(*,*) "[rank, (x,y,z), within]"
    end if


    !...initialize quest
    call quest_initialize( MPI_COMM_WORLD, FileName, .false., dim, unused, unused )
    call quest_mesh_bounds_min(mesh_bb_min)
    call quest_mesh_bounds_max(mesh_bb_max)
    call quest_mesh_center_of_mass(mesh_center_of_mass)

    !... Create random pts and query surface distance and containment
    do i=1,num_pts + 1
      if (i == 1) then
        x = mesh_center_of_mass(1)
        y = mesh_center_of_mass(2)
        z = mesh_center_of_mass(3)
      else
        x = random_double( mesh_bb_min(1), mesh_bb_max(1) )
        y = random_double( mesh_bb_min(2), mesh_bb_max(2) )
        z = random_double( mesh_bb_min(3), mesh_bb_max(3) )
      end if

      ins = quest_inside(x,y,z)

      write(*,Format) rank, x, y, z, ins
    end do

    !...finalize quest
    call quest_finalize()
  end subroutine run_containment_queries

end module


!-------------------------------------------------------------------------------
! Main Program
!-------------------------------------------------------------------------------
program quest_fortran

  use quest_fortran_usage

  implicit none

  call init_mpi()

  !...exercise the distance functions in quest module
  call run_distance_queries()

  !...exercise the containment functions in quest module
  call run_containment_queries()

  call finalize_mpi()

end program
