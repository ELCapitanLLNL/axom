copyright:
  - blah blah
  - yada yada
  -

splicer:
  f:
  -  fsplicer.f
  c:
  -  csplicer.c
  py:
  -  pysplicer.c

options:
#  module_name: exclass1_mod
  debug: True
  library: UserLibrary
  C_prefix: AA_
  namespace: example nested
  F_module_per_class: True
  # include files to add to module
  wrap_python: True

  PY_prefix: PP_

  # do not create get/set instance routines
  F_name_instance_get: yadda
  F_name_instance_set:
  

types:
  other:
    cpp_type: junk

#  string:
#    cpp_to_c : "isNameValid({cpp_var}) ? {cpp_var}.c_str() : NULL"

  SidreLength:
    typedef  : long
# defined in SidreTypes.hpp
    c_header : sidre/SidreTypes.h
    c_type   : ATK_SidreLength
    cpp_type : SidreLength
#    c_fortran: integer(C_LONG)
#    f_type   : integer(C_LONG)
##    f_module : iso_c_binding:C_LONG
#    f_module : 
#      iso_c_binding:
#      - C_LONG

  TypeID:
    typedef : int
    # enum for types
    c_header : sidre/SidreTypes.h
    cpp_header : sidre/SidreWrapperHelpers.hpp
    cpp_type: TypeID
    cpp_to_c : static_cast<int>({cpp_var})
    c_to_cpp :  getTypeID({c_var})

  # This example is pulled from spio
  # DataGroup is a type which is provided by another shroud wrapped library
  DataGroup:
    cpp_header: sidre/DataGroup.hpp
    cpp_type: asctoolkit::sidre::DataGroup
    f_type: type(datagroup)
    f_module:
      sidre_mod: [ datagroup ]
    c_type: SIDRE_datagroup
    c_header: sidre/wrapDataGroup.h
    c_fortran: type(C_PTR)
    f_to_c: '{f_var}%get_instance()'
    # cpp_local_var uses c_to_cpp to assign a value to a local variable
    cpp_local_var: True
    c_to_cpp: static_cast<{C_const}{cpp_type}{ptr}>(static_cast<{C_const}void *>({c_var}))
    PY_PyTypeObject: FillInTypeForGroup

classes:
  - name: ExClass1
    options:
      cpp_header: ExClass1.hpp
      # include files to add to module

    python:
      type: [ init, repr, richcompare ]

    methods:
    - decl: ExClass1 *new ( const string *name ) +constructor
      doxygen:
        brief:  constructor
        description: |
           longer description
           usually multiple lines
        return: return new instance

    - decl: void delete() +destructor
      doxygen:
        description:
           longer description
           joined with previous line

    - decl: int incrementCount(int incr)

    - decl: const string& getName() const
      result:
         attrs:
            len: aa_exclass1_get_name_length({F_instance_ptr})
      C_error_pattern: C_invalid_name
      PY_error_pattern: PY_invalid_name

    - decl: int GetNameLength() const
      doxygen:
        brief: helper function for Fortran
      helper: True
      options:
         C_code: return selfobj->getName().length();

    - decl: const string& getNameErrorCheck() const

    - decl: const string& getNameArg() const
    # This function will convert the return value into a argument
      options:
         F_string_result_as_arg: name

    - decl: ExClass2 *getRoot()

    - decl: int  getValue(int value)
      function_suffix: _from_int
    - decl: long getValue(long value)

    - decl: void *getAddr()
    - decl: bool hasAddr(bool in)

    - decl: void SplicerSpecial

  ######################################################################
  - name: ExClass2
    options:
      cpp_header: ExClass2.hpp
    python:
      type: [dealloc, print, compare, getattr, setattr,
             getattro, setattro,
             repr, hash, call, str,
             init, alloc, new, free, del]

    methods:
    - decl: ExClass2 *ExClass2 (const string *name) +constructor

      # test annotating arguments
      args:
      -  name: name
         random: 1
         attrs:
           random: 2
      -  name: extra

    - decl: void delete() +destructor

    - decl: const string& getName const
      # test annotating result
      result:
         attrs:
            len: aa_exclass2_get_name_length({F_instance_ptr})

# test variations of const for result and method
    - decl: const string& getName2
    - decl:       string& getName3 const
    - decl:       string& getName4

    - doxygen:
        brief: helper function for Fortran
      result:
         name: GetNameLength
         type: int
         attrs:
           const: true
      options:
          C_code: return selfobj->getName().length();

    # test forward declarations
    - decl: ExClass1 *get_class1(const ExClass1 *in)

    # typedefs that require modules
    - decl: void* declare(TypeID type, SidreLength len = 1)
      # by returning this,the C++ function allows chaining.
      # make them subroutines in Fortran.
      return_this: True
      fortran_generic:
        len:
        -  int
        -  long

    # void function
    - decl: void destroyall()

    # return typedef'd type
    - decl: TypeID getTypeID() const

#           template<typename ValueType>
    - decl: void setValue(ValueType value)
      cpp_template:
        ValueType:
        - int
        - long
        - float
        - double

#           template<typename ValueType>
    - decl: ValueType getValue()
      cpp_template:
        ValueType:
        - int
#        - long
#        - float
        - double


functions:
  - decl: void local_function1
    docs: yada yada yada

  # override the C code.
  -  decl: bool isNameValid(const std::string& name)
     options:
       C_code:  "return name != NULL;"
       F_code:  rv = name .ne. " "

  # return bool, no arguments.
  # This needs to generate a Fortran wrapper to convert the bool to logical
  -  decl: bool isInitialized()

  # overrides which each accept a string.
  # Test the name of generated 'bufferify' functions
  -  decl: void test_names(const std::string &name)
     # explicitly set suffix, otherwise it defaults to _0
     function_suffix:
  -  decl: void test_names(const std::string &name, int flag)
     function_suffix: _flag

  - decl: void testoptional(int i = 1, long j=2)

# test cpp_template, fortran_generic, overload
#  - decl: void Function10()
#  - decl: void Function10(ArgType arg1, std::string &name, double arg2 = 0)
#    options:
#      F_string_len_trim: True
#    cpp_template:
#      ArgType:
#      - int
#      - double
#    fortran_generic:
#       arg2:
#       - float
#       - double

  - decl: void testmpi(MPI_Comm comm)

  - decl: void testgroup1(DataGroup * grp)
  - decl: void testgroup2(const DataGroup * grp)

######################################################################
patterns:
    C_invalid_name: >
        if (! isNameValid({cpp_var})) {{
            return NULL;
        }}
    PY_invalid_name: >
        if (! isNameValid({cpp_var})) {{
            PyErr_SetString(PyExc_KeyError, "XXX need value of name");
            return NULL;
        }}


