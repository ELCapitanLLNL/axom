#
# Test the many variations of strings
#

options:
  debug: True
  library: strings
  cpp_header: strings.hpp
  wrap_python: False

functions:

- decl: const string& getName1()  +pure
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a string as character(*)

- decl: const string& getName2+len=30()
#- decl: const string& getName2()  +pure
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return string with fixed size (len=30)
#  options:
#    F_string_result_as_arg: output

- decl: const string& getName() # +pure
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a string as argument
  options:
    F_string_result_as_arg: output

- decl: void acceptStringConstReference(const std::string & arg1)
  doxygen:
    brief: Accept a const string reference
    description: |
       Save contents of arg1.
       arg1 is assumed to be intent(IN) since it is const
       Will copy in.

- decl: void acceptStringReference(std::string & arg1)
  doxygen:
    brief: Accept a string reference
    description: |
       Append "dog" to the end of arg1.
       arg1 is assumed to be intent(INOUT)
       Must copy in and copy out.

#- decl: void acceptStringPointer(std::string * arg1)
#  doxygen:
#    brief: Accept a string pointer

#- decl: void acceptStringInstance(std::string arg1)
#  doxygen:
#    brief: Accept a string instance




patterns:
    C_invalid_name: >
        if ({var}.empty()) {{
            return NULL;
        }}
    # return a blank field string if an error occurs
    C_invalid_name_as_buffer: >
        if ({var}.empty()) {{
            std::memset({f_string}, ' ', {f_string_len});
            return;
        }}

