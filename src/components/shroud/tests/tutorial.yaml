# Create a runnable program for the tutorial
#

options:
  debug: True
  library: Tutorial
  cpp_header: tutorial.hpp
  namespace: tutorial
  F_module_per_class: False
  wrap_python: True
  wrap_lua: True


types:
  TypeID:
    typedef  : int
    cpp_type : TypeID

  EnumTypeID:
    typedef  : int
    cpp_type : EnumTypeID
    c_to_cpp : static_cast<EnumTypeID>({c_var})
    cpp_to_c : static_cast<int>({cpp_var})


functions:
- decl: void Function1()
- decl: double Function2(double arg1, int arg2)
- decl: void Sum(int len, int *values+dimension+intent(in),
                 int *result+intent(out))
  options:
    # unable to deal with dimension
    wrap_lua: False
- decl: bool Function3(bool arg)
- decl: const std::string Function4a+len(30)(
    const std::string& arg1,
    const std::string& arg2 )
# +pure
#  result:
#    attrs:
#      len: 30
- decl: const std::string& Function4b(
    const std::string& arg1,
    const std::string& arg2 )
  options:
    F_string_result_as_arg: output

- decl: double Function5(double arg1 = 3.1415, bool arg2 = true)
  default_arg_suffix:
  -  
  -  _arg1
  -  _arg1_arg2

- decl: void Function6(const std::string& name)
  function_suffix: _from_name
- decl: void Function6(int indx)
  function_suffix: _from_index

- decl: void Function7(ArgType arg)
  cpp_template:
    ArgType:
    - int
    - double

- decl: RetType Function8()
  cpp_template:
    RetType:
    - int
    - double

- decl: void Function9(double arg)
  fortran_generic:
     arg:
     - float
     - double

# test cpp_template, fortran_generic, overload
#- decl: void Function10()
#- decl: void Function10(ArgType arg1, std::string &name, double arg2 = 0)
#  options:
#    F_string_len_trim: True
#  cpp_template:
#    ArgType:
#    - int
#    - double
#  fortran_generic:
#     arg2:
#     - float
#     - double


# test fortran_generic, overload
- decl: void Function10()
- decl: void Function10(const std::string &name, double arg2)
  options:
    F_string_len_trim: True
#  cpp_template:
#    ArgType:
#    - int
#    - double
  fortran_generic:
     arg2:
     - float
     - double

# overload with optional
- decl: int overload1(int num,
          int offset = 0, int stride = 1)
  default_arg_suffix:
  - _num
  - _num_offset
  - _num_offset_stride
- decl: int overload1(double type, int num,
          int offset = 0, int stride = 1)

# test F_string_result_as_arg and optional arguments
#- decl: const string& overload2(int flag = 0, bool flag2 = true) const
#  options:
#    F_string_result_as_arg: output

# TypeID and DataTypeId must be define in types
- decl: TypeID typefunc(TypeID arg)
- decl: EnumTypeID enumfunc(EnumTypeID arg)


##################################################

# Used with testing
- decl: const std::string& LastFunctionCalled() +pure

##################################################

classes:
- name: Class1
  options:
    # skip lua for classes for now
    wrap_lua: False
  methods:
  - decl: Class1 *new()  +constructor
  - decl: void delete()  +destructor
  - decl: void Method1()




##################################################
# Files which contain code to be inserted into generated code
splicer:
#  c:
#  -  ctutorialsplicer.c
  f:
  -  ftutorialsplicer.f
