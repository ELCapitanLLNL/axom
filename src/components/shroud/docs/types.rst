Types
=====

The wrappers generated by Shroud will make sure the argument types are
compatible between Fortran and C++. For the most common types there is
no work necessary since Fortran 2003 provides interoperability with C
via the iso_c_binding module.

Other types, such as logical and in particular strings, require additional
conversions.

Shroud maintains type maps which are used to generate conversion code
between Fortran, C and C++.  Many of the conversions reference other
format variables to describe the context.  These variables are

c_var
    The C name of the argument.

cpp_var
    Name of the C++ variable.

f_var
    Fortran variable name for argument.

All of the fields are defined in the references section and will only be used
by example in this section.


Integer and Real
----------------

The numeric types usually require no conversion.
In this case the type map is mainly used to generate declaration code 
for wrappers::

    types:
      int:
        c_type: int 
        cpp_type: int
        f_type: integer(C_INT)
        f_module:
          iso_c_binding:
          - C_INT
        f_cast: int({f_var}, C_INT)

One case where a converstion is required is when the Fortran argument
is one type and the C++ argument is another. This may happen when an
overloaded function is generated so that a ``C_INT`` or ``C_LONG``
argument may be passed to a C++ function function expecting a
``long``.  The **f_cast** field is used to convert the argument to the
type expected by the C++ function.





Bool Type
---------

C++ functions with a ``bool`` argument generate a Fortran wrapper with
a ``logical`` argument.  One of the goals of Shroud is to produce an
ideomatic interface.  Converting the types in the wrapper avoids the
awkardness of requiring the Fortran user to passing in
``.true._c_bool`` instead of just ``.true.``.

The type map is defined as::

    types:
      bool:
        c_type: bool 
        cpp_type: bool 
        f_type: logical 
        f_c_type: logical(C_BOOL) 
        f_module:
            iso_c_binding:
            -  C_BOOL
        f_statements:
           intent_in:
              c_local_var: true 
              pre_call:
              -  {c_var} = {f_var}  ! coerce to C_BOOL
           intent_out:
              c_local_var: true 
              post_call:
              -  {f_var} = {c_var}  ! coerce to logical
           result:
              need_wrapper: true

The first thing to notice is that **f_c_type** is defined.  This is
the type used in the Fortran interface for the C wrapper.  The type
is ``logical(C_BOOL)`` while **f_type**, the type of the Fortran
wrapper argument, is ``logical``.

The **f_statements** section describes code to add into the wrapper to
perform the converstion.  *c_var* and *f_var* default to the same
value as the argument name.  By setting **c_local_var**, a local
variable is generated for the call to the C wrapper.  It will be named
``SH_{f_var}``.

There is no Fortran intrinsic function to convert between default
``logical`` and ``logical(C_BOOL)``. The **pre_call** and
**post_call** sections will insert an assignment statement to allow
the compiler to do the conversion.

Example of using intent with ``bool`` arguments::

    decl: void checkBool(bool arg1, bool * arg2+intent(out), bool * arg3+intent(inout))

The resulting wrappers are::

    module userlibrary_mod
        interface
            subroutine c_check_bool(arg1, arg2, arg3) &
                    bind(C, name="AA_check_bool")
                use iso_c_binding
                implicit none
                logical(C_BOOL), value, intent(IN) :: arg1
                logical(C_BOOL), intent(OUT) :: arg2
                logical(C_BOOL), intent(INOUT) :: arg3
            end subroutine c_check_bool
        end interface
    contains
        subroutine check_bool(arg1, arg2, arg3)
            use iso_c_binding, only : C_BOOL
            implicit none
            logical, value, intent(IN) :: arg1
            logical(C_BOOL) SH_arg1
            logical, intent(OUT) :: arg2
            logical(C_BOOL) SH_arg2
            logical, intent(INOUT) :: arg3
            logical(C_BOOL) SH_arg3
            SH_arg1 = arg1  ! coerce to C_BOOL
            SH_arg3 = arg3  ! coerce to C_BOOL
            ! splicer begin check_bool
            call c_check_bool(  &
                SH_arg1,  &
                SH_arg2,  &
                SH_arg3)
            ! splicer end check_bool
            arg2 = SH_arg2  ! coerce to logical
            arg3 = SH_arg3  ! coerce to logical
        end subroutine check_bool
    end module userlibrary_mod

Since ``arg1`` in the YAML declaration is not a pointer it defaults to
``intent(IN)``.  The intent of the other two arguments are explicitly
annotated.

If a function return a ``bool`` result then a wrapper is always needed
to convert the result.  The **result** section sets **need_wrapper**
to force the wrapper to be created.  By default a function with no
argument would not need a wrapper since there will be no **pre_call**
or **post_call** code blocks.  Only the C interface would be required
since Fortran could call the C function directly.


Character Type
--------------

Fortran, C, and C++ all have their own semantics for character variables.

  * Fortran ``character`` variables know their length and are blank filled
  * C ``char *`` variables are assumed to be ``NULL`` terminated.
  * C++ ``std::string`` know their own length and are ``NULL`` terminated.

It is not sufficient to pass an address between Fortran and C++ like
it is with other native types.  In order to get ideomatic behavior in
the Fortran wrappers it is often necessary to copy the values.  This
is to account for blank filled vs ``NULL`` terminated.  It also helps
support ``const`` vs non-``const`` strings.

Any C++ function which has a ``char`` or ``std::string`` arguments
will also create an additional wrapper function which include
arguments for the length of the strings.  Most Fortran compiler use
this convention when passing ``CHARACTER`` arguments. Shroud makes
this convention explicit for two reasons:

* It allows an interface to be used.  Functions with an interface may
  not pass the hidden, non-standard length argument, depending on compiler.
* It may pass the result of ``len`` and/or ``len_trim``.

Arguments with the *intent(in)* annotation are also given the
*len_trim* annotation.  The assumption is that the trailing blanks are
not needed.  *intent(out)* adds a *len* annotation with the assumption
that the wrapper will copy the result and blank fill the argument.

The additional function will be named the same as the original function
with the option **bufferify_suffix** appended to the end.  The default 
value for the option is *_bufferify*.


A C 'bufferify' wrapper is created which accepts the address of the
Fortran character variable with a ``int`` argument for the declared
length of the variable (``len``) and/or an ``int`` argument for the
length with blanks trimmed off (``len_trim``).
The wrapper then uses these arguments to create a ``NULL`` terminated string
or a std::string instance.

Character Type Map
^^^^^^^^^^^^^^^^^^

There are several different type maps for character arguments.
The first is for type ``char``::

    types:
        char:
            base: string
            cpp_type: char
            c_type: char
            c_statements:
                intent_in:
                    cpp_local_var: True
                    cpp_header: <cstring>
                    pre_call:
                      - int {c_var_len} = std::strlen({c_var});
                      - char * {cpp_var} = new char [{c_var_len} + 1];
                      - std::strncpy({cpp_var}, {c_var}, {c_var_len});
                      - {cpp_var}[{c_var_len}] = '\0';
                    pre_call_trim:
                      - char * {cpp_var} = new char [{c_var_len} + 1];
                      - std::strncpy({cpp_var}, {c_var}, {c_var_len});
                      - {cpp_var}[{c_var_len}] = '\0';
                    post_call:
                      -  delete [] {cpp_var};
                intent_out:
                    cpp_local_var: True
                    pre_call:
                      - char * {cpp_var} = new char [{c_var_num} + 1];
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
                      - delete [] {cpp_var};
                    cpp_header: shroudrt.hpp
                result:
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
                    cpp_header: shroudrt.hpp
    
            f_type: character(*)
            f_c_type: character(kind=C_CHAR)
            f_module:
                iso_c_binding: null

``std::string`` has its own typemap::

    types:
        string:
            base: string
            cpp_type: std::string
            cpp_header: <string>
            cpp_to_c: {cpp_var}.c_str()
            c_type: char
    
            c_statements:
                intent_in:
                    cpp_local_var: True
                    pre_call:
                      - {c_const}std::string {cpp_var}({c_var});
                    pre_call_trim:
                      - {c_const}std::string {cpp_var}({c_var}, {c_var_trim});
                intent_out:
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
                    cpp_header: shroudrt.hpp'
                result:
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
                    cpp_header: shroudrt.hpp'
    
            f_type: character(*)
            f_c_type: character(kind=C_CHAR)
            f_module:
                iso_c_binding: none


Character Arguments
^^^^^^^^^^^^^^^^^^^

When an argument has intent *out*, then *len* attribute is added.
This allows the wrapper routine to know how much space as available for the output string.

When the argument has intent *in*, then the *len_trim* attribute is added to the *bufferify*
wrapper only.  The non-bufferify version will use ``strlen`` to compute the length of data.

Character Function
^^^^^^^^^^^^^^^^^^

.. This stuff was moved here from the tutorial and should be cleaned up

This attribute marks the routine as Fortran ``pure`` meaning there are
no side effects.  This is necessary because the function will be
called twice.  Once to compute the length of the result and once to
return the result.

The length of result variable ``rv`` is computed by calling the
function.  Once the result is declared, ``tut_function4a`` is called
which returns a ``type(C_PTR)``.  This result is dereferenced by
``fstr`` and copied into ``rv``.


.. XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

It is possible to avoid calling the C++ function twice by passing in
another argument to hold the result.  It would be up to the caller to
ensure it is long enough.  This is done by setting the option
**F_string_result_as_arg** to true.  Like all options, it may also be
set in the global **options** and it will apply to all functions::

.. update code examples from current output






    - decl: const std::string& Function4b(
        const std::string& arg1,
        const std::string& arg2)
      options:
        F_string_result_as_arg: output

The generated Fortran wrapper::

    subroutine function4b(arg1, arg2, output)
        use iso_c_binding, only : C_INT
        implicit none
        character(*), intent(IN) :: arg1
        character(*), intent(IN) :: arg2
        character(*), intent(OUT) :: output
        rv = c_function4b_bufferify(  &
            arg1,  &
            len_trim(arg1),  &
            arg2,  &
            len_trim(arg2),
            output,  &
            len(output))
    end subroutine function4b

The generated C wrapper::

    void TUT_function4b_bufferify(const char * arg1, int Larg1,
                                  const char * arg2, int Larg2,
                                  char * output, int Loutput) {
        const std::string SH_arg1(arg1, Larg1);
        const std::string SH_arg2(arg2, Larg2);
        const std::string & rv = Function4b(SH_arg1, SH_arg2);
        shroud_FccCopy(output, Loutput, rv.c_str());
        return;
    }


 ``FccCopy`` will copy the result into ``output`` and blank fill.


.. char **


Complex Type
------------


Derived Types
-------------



* chained function calls
