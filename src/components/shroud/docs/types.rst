Types
=====

The wrappers generated by Shroud will make sure the argument types are
compatible between Fortran and C++. For the most common types there is
no work necessary since Fortran 2003 provides interoperability with C
via the iso_c_binding module.

Other types, such as logical and in particular strings, require additional
conversions.

Shroud maintains type maps which are used to generate conversion code
between Fortran, C and C++.  Many of the conversions reference other
format variables to describe the context.  These variables are

c_var
    The C name of the argument.

cpp_var
    Name of the C++ variable.

f_var
    Fortran variable name for argument.

All of the fields are defined in the references section and will only be used
by example in this section.


Integer and Real
----------------

The numeric types usually require no conversion.
In this case the type map is mainly used to generate declaration code 
for wrappers::

    types:
      int:
        c_type: int 
        cpp_type: int
        f_type: integer(C_INT)
        f_module:
          iso_c_binding:
          - C_INT
        f_cast: int({f_var}, C_INT)

One case where a converstion is required is when the Fortran argument
is one type and the C++ argument is another. This may happen when an
overloaded function is generated so that a ``C_INT`` or ``C_LONG``
argument may be passed to a C++ function function expecting a
``long``.  The **f_cast** field is used to convert the argument to the
type expected by the C++ function.





Bool
----

C++ functions with a ``bool`` argument generate a Fortran wrapper with
a ``logical`` argument.  One of the goals of Shroud is to produce an
ideomatic interface.  Converting the types in the wrapper avoids the
awkardness of requiring the Fortran user to passing in
``.true._c_bool`` instead of just ``.true.``.

The type map is defined as::

    types:
      bool:
        c_type: bool 
        cpp_type: bool 
        f_type: logical 
        f_c_type: logical(C_BOOL) 
        f_module:
            iso_c_binding:
            -  C_BOOL
        f_statements:
           intent_in:
              c_local_var: true 
              pre_call:
              -  {c_var} = {f_var}  ! coerce to C_BOOL
           intent_out:
              c_local_var: true 
              post_call:
              -  {f_var} = {c_var}  ! coerce to logical
           result:
              need_wrapper: true

The first thing to notice is that **f_c_type** is defined.  This is
the type used in the Fortran interface for the C wrapper.  The type
is ``logical(C_BOOL)`` while **f_type**, the type of the Fortran
wrapper argument, is ``logical``.

The **f_statements** section describes code to add into the Fortran
wrapper to perform the converstion.  *c_var* and *f_var* default to
the same value as the argument name.  By setting **c_local_var**, a
local variable is generated for the call to the C wrapper.  It will be
named ``SH_{f_var}``.

There is no Fortran intrinsic function to convert between default
``logical`` and ``logical(C_BOOL)``. The **pre_call** and
**post_call** sections will insert an assignment statement to allow
the compiler to do the conversion.

Example of using intent with ``bool`` arguments::

    decl: void checkBool(bool arg1, bool * arg2+intent(out), bool * arg3+intent(inout))

The resulting wrappers are::

    module userlibrary_mod
        interface
            subroutine c_check_bool(arg1, arg2, arg3) &
                    bind(C, name="AA_check_bool")
                use iso_c_binding
                implicit none
                logical(C_BOOL), value, intent(IN) :: arg1
                logical(C_BOOL), intent(OUT) :: arg2
                logical(C_BOOL), intent(INOUT) :: arg3
            end subroutine c_check_bool
        end interface
    contains
        subroutine check_bool(arg1, arg2, arg3)
            use iso_c_binding, only : C_BOOL
            implicit none
            logical, value, intent(IN) :: arg1
            logical(C_BOOL) SH_arg1
            logical, intent(OUT) :: arg2
            logical(C_BOOL) SH_arg2
            logical, intent(INOUT) :: arg3
            logical(C_BOOL) SH_arg3
            SH_arg1 = arg1  ! coerce to C_BOOL
            SH_arg3 = arg3  ! coerce to C_BOOL
            ! splicer begin check_bool
            call c_check_bool(  &
                SH_arg1,  &
                SH_arg2,  &
                SH_arg3)
            ! splicer end check_bool
            arg2 = SH_arg2  ! coerce to logical
            arg3 = SH_arg3  ! coerce to logical
        end subroutine check_bool
    end module userlibrary_mod

Since ``arg1`` in the YAML declaration is not a pointer it defaults to
``intent(IN)``.  The intent of the other two arguments are explicitly
annotated.

If a function returns a ``bool`` result then a wrapper is always needed
to convert the result.  The **result** section sets **need_wrapper**
to force the wrapper to be created.  By default a function with no
argument would not need a wrapper since there will be no **pre_call**
or **post_call** code blocks.  Only the C interface would be required
since Fortran could call the C function directly.


Character
---------

Fortran, C, and C++ each have their own semantics for character variables.

  * Fortran ``character`` variables know their length and are blank filled
  * C ``char *`` variables are assumed to be ``NULL`` terminated.
  * C++ ``std::string`` know their own length and can provied a ``NULL`` terminated pointer.

It is not sufficient to pass an address between Fortran and C++ like
it is with other native types.  In order to get ideomatic behavior in
the Fortran wrappers it is often necessary to copy the values.  This
is to account for blank filled vs ``NULL`` terminated.

..  It also helps support ``const`` vs non-``const`` strings.

Any C++ function which has ``char`` or ``std::string`` arguments or
result will create an additional C function which include additional
arguments for the length of the strings.  Most Fortran compiler use
this convention when passing ``CHARACTER`` arguments. Shroud makes
this convention explicit for three reasons:

* It allows an interface to be used.  Functions with an interface may
  not pass the hidden, non-standard length argument, depending on compiler.
* It may pass the result of ``len`` and/or ``len_trim``.
  The convention just passes the length.
* Returning character argument from C to Fortran is non-portable.

Arguments with the *intent(in)* annotation are given the *len_trim*
annotation.  The assumption is that the trailing blanks are not part
of the data but only padding.  Return values and *intent(out)*
arguments add a *len* annotation with the assumption that the wrapper
will copy the result and blank fill the argument so it need to know
the declared length.

The additional function will be named the same as the original
function with the option **C_bufferify_suffix** appended to the end.
The Fortran wrapper will use the original function name, but call the
C function which accepts the length arguments.

The character type maps use the **c_statements** section to define
code which will be inserted into the C wrapper. *intent_in*,
*intent_out*, and *result* subsections add actions for the C wrapper.
*intent_in_buf*, *intent_out_buf*, and *result_buf* are used for
arguments with the *len* and *len_trim* annotations in the additional
C wrapper.


Char
^^^^

The type map::

    types:
        char:
            base: string
            cpp_type: char
            c_type: char
            c_statements:
                intent_in_buf:
                    cpp_local_var: True
                    cpp_header: <cstring>
                    pre_call:
                      - char * {cpp_var} = new char [{c_var_trim} + 1];
                      - std::strncpy({cpp_var}, {c_var}, {c_var_trim});
                      - {cpp_var}[{c_var_trim}] = '\0';
                    post_call:
                      -  delete [] {cpp_var};
                intent_out_buf:
                    cpp_local_var: True
                    cpp_header: shroudrt.hpp
                    pre_call:
                      - char * {cpp_var} = new char [{c_var_len} + 1];
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
                      - delete [] {cpp_var};
                result_buf:
                    cpp_header: shroudrt.hpp
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
    
            f_type: character(*)
            f_c_type: character(kind=C_CHAR)
            f_c_module:
                iso_c_binding:
                  - C_CHAR

The function ``passCharPtr(dest, src)`` is equivalent to the Fortran
statement ``dest = str``::

    - decl: void passCharPtr(char *dest, const char *src)

.. from tests/strings.cpp

The intent of the arguments is inferred from the declaration.
``dest`` is *intent(out)* since it is a pointer.  ``src`` is
*intent(in)* since it is ``const``.

This single line will create five different wrappers.  The first is the 
pure C version.  The only feature this provides to Fortran is the ability
to call a C++ function by wrapping it in an ``extern "C"`` function::

    void STR_pass_char_ptr(char * dest, const char * src)
    {
        passCharPtr(dest, src);
        return;
    }

A Fortran interface for the routine is generated which will allow the
function to be called directly::

        subroutine c_pass_char_ptr(dest, src) &
                bind(C, name="STR_pass_char_ptr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr

The user is responsible for providing the ``NULL`` termination.
The result in ``str`` will also be ``NULL`` terminated instead of 
blank filled.::

    character(30) str
    call c_pass_char_ptr(dest=str, src="mouse" // C_NULL_CHAR)

An additional C function is automatically declared which is summarized as::

    - decl: void passCharPtr(char * dest+intent(out)+len(Ndest),
                             const char * src+intent(in)+len_trim(Lsrc))

And generates::

    void STR_pass_char_ptr_bufferify(char * dest, int Ndest, const char * src, int Lsrc)
    {
        char * SH_dest = new char [Ndest + 1];
        char * SH_src = new char [Lsrc + 1];
        std::strncpy(SH_src, src, Lsrc);
        SH_src[Lsrc] = '\0';
        passCharPtr(SH_dest, SH_src);
        shroud_FccCopy(dest, Ndest, SH_dest);
        delete [] SH_dest;
        delete [] SH_src;
        return;
    }

``Ndest`` is the declared length of argument ``dest`` and ``Lsrc`` is
the trimmed length of argument ``src``.  These generated names must
not conflict with any other arguments.  There are two ways to set the
names.  First by using the options **C_var_len_template** and
**C_var_trim_template**. This can be used to control how the names are
generated for all functions if set globally or just a single function
if set in the function's options.  The other is by explicitly setting
the *len* and *len_trim* annotations which only effect a single
declaration.

The pre_call code creates space for the C strings by allocating
buffers with space for an additional character (the ``NULL``).  The
*intent(in)* string copies the data and adds an explicit terminating
``NULL``.  The function is called then the post_call section copies
the result back into the ``dest`` argument and deletes the scratch
space.  ``shroud_FccCopy`` is a function provided by Shroud which
copies character into the destination up to ``Ndest`` characters, then
blank fill any remaining space.

The Fortran interface is generated::

        subroutine c_pass_char_ptr_bufferify(dest, Ndest, src, Lsrc) &
                bind(C, name="STR_pass_char_ptr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: Ndest
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: Lsrc
        end subroutine c_pass_char_ptr_bufferify

And finally, the Fortran wrapper with calls to ``len`` and ``len_trim``::

    subroutine pass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT
        character(*), intent(OUT) :: dest
        character(*), intent(IN) :: src
        call c_pass_char_ptr_bufferify(  &
            dest,  &
            len(dest, kind=C_INT),  &
            src,  &
            len_trim(src, kind=C_INT))
    end subroutine pass_char_ptr

Now the function can be called without the user aware that it is written in C++::

    character(30) str
    call pass_char_ptr(dest=str, src="mouse")


std::string
^^^^^^^^^^^

The ``std::string`` type map is very similar to ``char`` but provides some
additional sections to convert between ``char *`` and ``std::string``::

    types:
        string:
            base: string
            cpp_type: std::string
            cpp_header: <string>
            cpp_to_c: {cpp_var}.c_str()
            c_type: char
    
            c_statements:
                intent_in:
                    cpp_local_var=True,
                    pre_call:
                      - {c_const}std::string {cpp_var}({c_var});
                intent_out:
                    cpp_header='<cstring>'
                    post_call:
                      - strcpy({c_var}, {cpp_val});

                intent_in_buf:
                    cpp_local_var: True
                    pre_call:
                      - {c_const}std::string {cpp_var}({c_var});
                    pre_call_buf:
                      - {c_const}std::string {cpp_var}({c_var}, {c_var_trim});
                intent_out_buf:
                    cpp_header: shroudrt.hpp'
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
                result_buf:
                    cpp_header: shroudrt.hpp'
                    post_call:
                      - shroud_FccCopy({c_var}, {c_var_len}, {cpp_val});
    
            f_type: character(*)
            f_c_type: character(kind=C_CHAR)
            f_c_module:
                iso_c_binding:
                  - C_CHAR


To demonstrate this type map, ``acceptStringReference`` is a function which
will accept and modify a string reference::

    - decl: void acceptStringReference(std::string & arg1)

A reference defaults to *intent(inout)* and will add both the *len*
and *len_trim* annotations.

Each generated version will convert ``arg`` into a ``std::string``, call the function,
then copy the results back. The important thing to notice is that the pure C version
could do very bad things since it does not know how much space it has to copy into.
The second version knows the allocated length of the argument::

    void STR_accept_string_reference(char * arg1)
    {
        std::string SH_arg1(arg1);
        acceptStringReference(SH_arg1);
        strcpy(arg1, SH_arg1.c_str());
        return;
    }

    void STR_accept_string_reference_bufferify(char * arg1, int Larg1, int Narg1)
    {
        std::string SH_arg1(arg1, Larg1);
        acceptStringReference(SH_arg1);
        shroud_FccCopy(arg1, Narg1, SH_arg1.c_str());
        return;
    }

Each interface matches the C wrapper::

        subroutine c_accept_string_reference(arg1) &
                bind(C, name="STR_accept_string_reference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_reference

        subroutine c_accept_string_reference_bufferify(arg1, Larg1, Narg1) &
                bind(C, name="STR_accept_string_reference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Larg1
            integer(C_INT), value, intent(IN) :: Narg1
        end subroutine c_accept_string_reference_bufferify

And the Fortran wrapper provides the correct values for the *len* and
*len_trim* arguments::

    subroutine accept_string_reference(arg1)
        use iso_c_binding, only : C_INT
        character(*), intent(INOUT) :: arg1
        ! splicer begin accept_string_reference
        call c_accept_string_reference_bufferify(  &
            arg1,  &
            len_trim(arg1, kind=C_INT),  &
            len(arg1, kind=C_INT))
        ! splicer end accept_string_reference
    end subroutine accept_string_reference

Character functions
^^^^^^^^^^^^^^^^^^^

Function which return a ``char *`` provide an additional challange::


    - decl: const char * getChar1()  +pure
    - decl: const char * getChar2+len=30()
    - decl: const char * getChar3()
      options:
         F_string_result_as_arg: output

Each generates very similar C wrappers::

    const char * STR_get_char1()
    {
        const char * SH_rv = getChar1();
        return SH_rv;
    }

    void STR_get_char1_bufferify(char * SH_F_rv, int NSH_F_rv)
    {
        const char * SH_rv = getChar1();
        shroud_FccCopy(SH_F_rv, NSH_F_rv, SH_rv);
        return;
    }

But the Fortran wrappers work differently::

    function get_char1() result(SH_rv)
        use iso_c_binding, only : C_CHAR
        character(kind=C_CHAR, len=strlen_ptr(c_get_char1())) :: SH_rv
        SH_rv = fstr(c_get_char1())
    end function get_char1

    function get_char2() result(SH_rv)
        use iso_c_binding, only : C_CHAR, C_INT
        character(kind=C_CHAR, len=30) :: SH_rv
        call c_get_char2_bufferify(  &
            SH_rv,  &
            len(SH_rv, kind=C_INT))
    end function get_char2

    subroutine get_char3(output)
        use iso_c_binding, only : C_INT
        character(*), intent(OUT) :: output
        call c_get_char3_bufferify(  &
            output,  &
            len(output, kind=C_INT))
    end subroutine get_char3




.. ######################################################################



Character Function
^^^^^^^^^^^^^^^^^^

.. This stuff was moved here from the tutorial and should be cleaned up

This attribute marks the routine as Fortran ``pure`` meaning there are
no side effects.  This is necessary because the function will be
called twice.  Once to compute the length of the result and once to
return the result.

The length of result variable ``rv`` is computed by calling the
function.  Once the result is declared, ``tut_function4a`` is called
which returns a ``type(C_PTR)``.  This result is dereferenced by
``fstr`` and copied into ``rv``.


.. XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

It is possible to avoid calling the C++ function twice by passing in
another argument to hold the result.  It would be up to the caller to
ensure it is long enough.  This is done by setting the option
**F_string_result_as_arg** to true.  Like all options, it may also be
set in the global **options** and it will apply to all functions::

.. update code examples from current output






    - decl: const std::string& Function4b(
        const std::string& arg1,
        const std::string& arg2)
      options:
        F_string_result_as_arg: output

The generated Fortran wrapper::

    subroutine function4b(arg1, arg2, output)
        use iso_c_binding, only : C_INT
        implicit none
        character(*), intent(IN) :: arg1
        character(*), intent(IN) :: arg2
        character(*), intent(OUT) :: output
        rv = c_function4b_bufferify(  &
            arg1,  &
            len_trim(arg1),  &
            arg2,  &
            len_trim(arg2),
            output,  &
            len(output))
    end subroutine function4b

The generated C wrapper::

    void TUT_function4b_bufferify(const char * arg1, int Larg1,
                                  const char * arg2, int Larg2,
                                  char * output, int Loutput) {
        const std::string SH_arg1(arg1, Larg1);
        const std::string SH_arg2(arg2, Larg2);
        const std::string & rv = Function4b(SH_arg1, SH_arg2);
        shroud_FccCopy(output, Loutput, rv.c_str());
        return;
    }


 ``FccCopy`` will copy the result into ``output`` and blank fill.


.. char **


Complex Type
------------


Derived Types
-------------



* chained function calls
