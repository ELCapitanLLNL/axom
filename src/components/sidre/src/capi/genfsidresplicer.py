#
# Routines to generate splicers for wrappers.
# Used to generate several variations of a routine for Fortran.
# Similar to templates in C++.
#
from __future__ import print_function
import sys

types = (
    ( 'int',    'integer(C_INT)',  'ATK_C_INT_T'),
    ( 'long',   'integer(C_LONG)', 'ATK_C_LONG_T'),
    ( 'float',  'real(C_FLOAT)',   'ATK_C_FLOAT_T'),
    ( 'double', 'real(C_DOUBLE)',  'ATK_C_DOUBLE_T'),
)

# XXX - only doing 0-d and 1-d for now
maxdims = 1

def num_metabuffers():
    return len(types) * (maxdims + 1) # include scalars
######################################################################

def print_register_static(d):
    # typename - part of function name
    # nd       - number of dimensions
    # f_type   - fortran type
    # shape     - :,:, to match nd
    if d['rank'] == 0:
        size = '1_C_LONG'
    else:
        size = 'size(value, kind=1_C_LONG)'

    return """
! Generated by genfsidresplicer.py
function datagroup_register_static_{typename}_{nd}(group, name, value) result(rv)
    use iso_c_binding
    implicit none

    interface
       function ATK_register_static(group, name, lname, addr, type, nitems) result(rv) bind(C,name="ATK_register_static")
       use iso_c_binding
       type(C_PTR), value, intent(IN)     :: group
       character(kind=C_CHAR), intent(IN) :: name(*)
       integer(C_INT), value, intent(IN)  :: lname
       type(C_PTR), value,     intent(IN) :: addr
       integer(C_INT), value, intent(IN)  :: type
       integer(C_LONG), value, intent(IN) :: nitems
       type(C_PTR) rv
       end function ATK_register_static
    end interface
    type(C_PTR), external :: ATK_C_LOC

    class(datagroup), intent(IN) :: group
    character(*), intent(IN) :: name
    {f_type}, target, intent(IN) :: value{shape}
    integer(C_INT) :: lname
    type(dataview) :: rv
    integer(C_LONG) :: nitems
    integer(C_INT) :: type = {atk_type}

    lname = len_trim(name)
    nitems = {size}
    rv%voidptr = ATK_register_static(group%voidptr, name, lname, ATK_C_LOC(value), type, nitems)
end function datagroup_register_static_{typename}_{nd}""".format(size=size, **d)


def print_register_allocatable(d):
    # typename - part of function name
    # nd       - number of dimensions
    # f_type   - fortran type
    # shape     - :,:, to match nd
    if d['rank'] == -1:
        raise NotImplementedError
        return """
! Generated by genfsidresplicer.py
function datagroup_register_allocatable_{typename}_{nd}(group, name, value) result(rv)
    use iso_c_binding
    implicit none
    class(datagroup), intent(IN) :: group
    character(*), intent(IN) :: name
    {f_type}, allocatable, intent(IN) :: value{shape}
    type(dataview) :: rv
    rv%voidptr = C_NULL_PTR
end subroutine datagroup_register_allocatable_{typename}_{nd}""".format(**d)

    elif d['rank'] == 0:
        return """
! Generated by genfsidresplicer.py
function datagroup_register_allocatable_{typename}_{nd}(group, name, value) result(rv)
    use iso_c_binding
    implicit none

    interface
       function ATK_register_allocatable_{typename}_{nd}(group, name, lname, array, indx) result(rv)
       use iso_c_binding
       type(C_PTR), value, intent(IN)    :: group
       character(*), intent(IN)          :: name
       integer(C_INT), value, intent(IN) :: lname
       {f_type}, allocatable, intent(IN) :: array{shape}
       integer(C_INT), value, intent(IN) :: indx
       type(C_PTR) rv
       end function ATK_register_allocatable_{typename}_{nd}
    end interface

    class(datagroup), intent(IN) :: group
    character(*), intent(IN) :: name
    {f_type}, allocatable, intent(IN) :: value{shape}
    integer(C_INT) :: lname
    type(dataview) :: rv
    integer(C_INT) :: indx = {index}

    lname = len_trim(name)
    rv%voidptr = ATK_register_allocatable_{typename}_{nd}(group%voidptr, name, lname, value, indx)
end function datagroup_register_allocatable_{typename}_{nd}""".format(**d)

    elif d['rank'] == 1:
        return """
! Generated by genfsidresplicer.py
function datagroup_register_allocatable_{typename}_{nd}(group, name, value) result(rv)
    use iso_c_binding
    implicit none

    interface
       function ATK_register_allocatable_{typename}_{nd}(group, name, lname, array, indx) result(rv)
       use iso_c_binding
       type(C_PTR), value, intent(IN)    :: group
       character(*), intent(IN)          :: name
       integer(C_INT), value, intent(IN) :: lname
       {f_type}, allocatable, intent(IN) :: array{shape}
       integer(C_INT), value, intent(IN) :: indx
       type(C_PTR) rv
       end function ATK_register_allocatable_{typename}_{nd}
    end interface

    class(datagroup), intent(IN) :: group
    character(*), intent(IN) :: name
    {f_type}, allocatable, intent(IN) :: value{shape}
    integer(C_INT) :: lname
    type(dataview) :: rv
    integer(C_INT) :: indx = {index}

    lname = len_trim(name)
    rv%voidptr = ATK_register_allocatable_{typename}_{nd}(group%voidptr, name, lname, value, indx)
end function datagroup_register_allocatable_{typename}_{nd}""".format(**d)
    else:
        raise RuntimeError("rank too large in print_register_allocatable")


def print_get_value(d):
    # typename - part of function name
    # nd       - number of dimensions
    # f_type   - fortran type
    # shape     - :,:, to match nd
    if d['rank'] == -1:
        return """
! Generated by genfsidresplicer.py
subroutine dataview_get_value_{typename}_{nd}(view, value)
    use iso_c_binding
    implicit none
    class(dataview), intent(IN) :: view
    {f_type}, intent(OUT) :: value
    {f_type}, pointer :: value_ptr
    type(C_PTR) cptr

    cptr = view%get_data_pointer()
    call c_f_pointer(cptr, value_ptr)
    value = value_ptr
end subroutine dataview_get_value_{typename}_{nd}""".format(**d)

    elif d['rank'] == 0:
        return """
! Generated by genfsidresplicer.py
subroutine dataview_get_value_{typename}_{nd}(view, value)
    use iso_c_binding
    implicit none
    class(dataview), intent(IN) :: view
    {f_type}, pointer, intent(OUT) :: value{shape}
    type(C_PTR) cptr

    cptr = view%get_data_pointer()
    call c_f_pointer(cptr, value)
end subroutine dataview_get_value_{typename}_{nd}""".format(**d)

    elif d['rank'] == 1:
        return """
! Generated by genfsidresplicer.py
subroutine dataview_get_value_{typename}_{nd}(view, value)
    use iso_c_binding
    implicit none
    class(dataview), intent(IN) :: view
    {f_type}, pointer, intent(OUT) :: value{shape}
    type(C_PTR) cptr
    integer(C_SIZE_T) nelems

    cptr = view%get_data_pointer()
    nelems = view%get_number_of_elements()
    call c_f_pointer(cptr, value, [ nelems ])
end subroutine dataview_get_value_{typename}_{nd}""".format(**d)
    else:
        raise RuntimeError("rank too large in print_get_value")


def type_bound_procedure_part(d):
    return 'procedure :: {stem}_{typename}_{nd} => {wrap_class}_{stem}_{typename}_{nd}'.format(**d)

def type_bound_procedure_generic(d):
    return '{stem}_{typename}_{nd}'.format(**d)

def type_bound_procedure_generic_post(lines, generics, stem):
    lines.append('generic :: %s => &' % stem)
    for gen in generics[:-1]:
        lines.append('    ' + gen + ',  &')
    lines.append('    ' + generics[-1])


def foreach_value(lines, fcn, **kwargs):
    """ Call fcn once for each type, appending to lines.
    kwargs - additional values for format dictionary.
    """
    shape = []
    lbound = []
    for nd in range(maxdims + 1):
        shape.append(':')
        lbound.append('lbound(value,%d)' % (nd+1))
    d = {}
    d.update(kwargs)
    indx = 0
    for typetuple in types:
        d['typename'], d['f_type'], d['atk_type'] = typetuple

        # scalar values
        # XXX - generic does not distinguish between pointer and non-pointer
#        d['rank'] = -1
#        d['nd'] = 'scalar'
#        d['shape'] = ''
#        lines.append(fcn(d))

        # scalar pointers
        d['index'] = indx
        indx += 1
        d['rank'] = 0
        d['nd'] = 'scalar_ptr'
        d['shape'] = ''
        d['lower_bound'] = ''
        lines.append(fcn(d))

        for nd in range(1,maxdims+1):
            d['index'] = indx
            indx += 1
            d['rank'] = nd
            d['nd'] = '%dd_ptr' % nd
            d['shape'] = '(' + ','.join(shape[:nd]) + ')'
            d['lower_bound'] = '(' + ','.join(lbound[:nd]) + ')'
            lines.append(fcn(d))

def print_lines(printer, fcn, **kwargs):
    """Print output using printer function.
    [Used with cog]
    """
    lines = []
    foreach_value(lines, fcn, **kwargs)
    for line in lines:
        printer(line)

def gen_fortran():
    print('! Generated by genfsidresplicer.py')

    # DataGroup
    lines = []

    generics = []
    extra = dict(
        wrap_class='datagroup',
        stem='register_allocatable',
        )
    foreach_value(lines, type_bound_procedure_part, **extra)
    foreach_value(generics, type_bound_procedure_generic, **extra)
    type_bound_procedure_generic_post(lines, generics, 'register_allocatable')

    generics = []
    extra = dict(
        wrap_class='datagroup',
        stem='register_static',
        )
    foreach_value(lines, type_bound_procedure_part, **extra)
    foreach_value(generics, type_bound_procedure_generic, **extra)
    type_bound_procedure_generic_post(lines, generics, 'register_static')

    print('! splicer begin class.DataGroup.type_bound_procedure_part')
    for line in lines:
        print(line)
    print('! splicer end class.DataGroup.type_bound_procedure_part')

    print()
    print('------------------------------------------------------------')
    print()

    print('! splicer begin class.DataGroup.additional_functions')
    lines = []
    foreach_value(lines, print_register_allocatable)
    foreach_value(lines, print_register_static)
    for line in lines:
        print(line)
    print('! splicer end class.DataGroup.additional_functions')


    # DataView
    extra = dict(
        wrap_class='dataview',
        stem='get_value',
        )
    lines = []
    foreach_value(lines, type_bound_procedure_part, **extra)
    generics = []
    foreach_value(generics, type_bound_procedure_generic, **extra)
    type_bound_procedure_generic_post(lines, generics, 'get_value')

    print('! splicer begin class.DataView.type_bound_procedure_part')
    for line in lines:
        print(line)
    print('! splicer end class.DataView.type_bound_procedure_part')

    print()
    print('------------------------------------------------------------')
    print()

    print('! splicer begin class.DataView.additional_functions')
    lines = []
    foreach_value(lines, print_get_value)
    for line in lines:
        print(line)
    print('! splicer end class.DataView.additional_functions')


######################################################################

def print_atk_register_allocatable(d):
    """Write C++ routine to accept Fortran allocatable.
    """
# XXX - need cmake macro to mangle name portably
    return """
// Fortran callable routine.
// Needed for each type-kind-rank to get address of allocatable array.
// array is address of allocatable, not the result of C_LOC(array)
void *atk_register_allocatable_{typename}_{nd}_(
    DataGroup *group,
    char *name, int lname,
    void *array, int indx)
{{
    return register_allocatable(group, std::string(name, lname), array, indx); 
}}""".format(**d)

######################################################################

def print_atk_size_allocatable(d):
    """Write Fortran routine to return size of allocatable.
    """
# XXX - need cmake macro to mangle name portably
    if d['rank'] == 0:
        return """
function atk_size_allocatable_{typename}_{nd}(array) result(rv)
    use iso_c_binding
    implicit none
    {f_type}, allocatable, intent(IN) :: array{shape}
    integer(C_SIZE_T) :: rv
    rv = 1
end function atk_size_allocatable_{typename}_{nd}""".format(**d)
    else:
        return """
function atk_size_allocatable_{typename}_{nd}(array) result(rv)
    use iso_c_binding
    implicit none
    {f_type}, allocatable, intent(IN) :: array{shape}
    integer(C_SIZE_T) :: rv
    rv = size(array)
end function atk_size_allocatable_{typename}_{nd}""".format(**d)

def print_atk_size_allocatable_header(d):
    """Write C++ declarations for Fortran routines.
    """
# XXX - need cmake macro to mangle name portably
    return "size_t atk_size_allocatable_{typename}_{nd}_(void * array);".format(**d)

######################################################################

def print_atk_address_allocatable(d):
    """Write Fortran routine to return address of allocatable.
    Use C_LOC and add TARGET attribute
    """
# XXX - need cmake macro to mangle name portably
    return """
function atk_address_allocatable_{typename}_{nd}(array) result(rv)
    use iso_c_binding
    implicit none
    {f_type}, allocatable, intent(IN), target :: array{shape}
    type(C_PTR) :: rv
    rv = c_loc(array)
end function atk_address_allocatable_{typename}_{nd}""".format(**d)

def print_atk_address_allocatable_header(d):
    return "void *atk_address_allocatable_{typename}_{nd}_(void * array);".format(**d)

######################################################################

def print_atk_allocate_allocatable(d):
    """Write Fortran routine to allocate an allocatable.
    """
# XXX - need cmake macro to mangle name portably
    if d['rank'] == 0:
        size = '';
    elif d['rank'] == 1:
        size = '(nitems)'
    else:
        raise NotImplementedError
    

    return """
subroutine atk_allocate_allocatable_{typename}_{nd}(array, nitems)
    use iso_c_binding
    implicit none
    {f_type}, allocatable, intent(OUT), target :: array{shape}
    integer(C_INT), value, intent(IN) :: nitems
    allocate(array{size})
end subroutine atk_allocate_allocatable_{typename}_{nd}""".format(size=size, **d)

def print_atk_allocate_allocatable_header(d):
    return "void atk_allocate_allocatable_{typename}_{nd}_(void *array, long nitems);".format(**d)

######################################################################

def print_fptrs_cache(d):
    return """
{{
  {rank},   // rank
  {atk_type},
  atk_size_allocatable_{typename}_{nd}_,
  atk_address_allocatable_{typename}_{nd}_,
  atk_allocate_allocatable_{typename}_{nd}_
}},
""".format(**d)


######################################################################

if __name__ == '__main__':
    try:
        cmd = sys.argv[1]
    except IndexError:
        raise RuntimeError("Missing command line argument")

    if cmd == 'fortran':
        # fortran splicers
        gen_fortran()
    else:
        raise RuntimeError("Unknown command")
